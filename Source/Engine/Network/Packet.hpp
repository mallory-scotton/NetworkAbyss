///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <Engine/Utils/Types.hpp>
#include <Engine/Utils/Vec2.hpp>
#include <stdexcept>
#include <cstring>

///////////////////////////////////////////////////////////////////////////////
// Namespace tkd
///////////////////////////////////////////////////////////////////////////////
namespace tkd
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class Packet
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    static const Uint64 MAX_SIZE = 1024UL;

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Connect
    {
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Disconnect
    {
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct PlayerMove
    {
        Vec2f position{0.f};
        int id{-1};
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct PlayerList
    {
        Uint32 count{0};
        UMap<int, Vec2f> players{};
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct PlayerJoined
    {
        int id{-1};
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct PlayerLeft
    {
        int id{-1};
    };

private:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    Variant<
        Connect,
        Disconnect,
        PlayerMove,
        PlayerList,
        PlayerJoined,
        PlayerLeft
    > m_data;                           //<!
    Array<Byte, MAX_SIZE> m_buffer;     //<!
    Uint64 m_pos = 0;                   //<!

private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    /// \tparam Ts
    ///
    /// \param
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T, typename... Ts>
    static constexpr bool isInParameterPack(const Variant<Ts...>*)
    {
        return (std::disjunction_v<std::is_same<T, Ts>...>);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    static constexpr bool isPacketSubType = isInParameterPack<T>(
        decltype(&m_data)(nullptr)
    );

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    Packet(void) = default;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param subType
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    explicit Packet(const T& subType)
    {
        static_assert(isPacketSubType<T>, "T must be a subtype of Packet");
        if constexpr (isPacketSubType<T>) {
            m_data = subType;
            this->serialize();
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    bool is(void) const
    {
        static_assert(isPacketSubType<T>, "T must be a subtype of Packet");
        if constexpr (isPacketSubType<T>)
            return (std::holds_alternative<T>(m_data));
        return (false);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    T* getIf(void)
    {
        static_assert(isPacketSubType<T>, "T must be a subtype of Packet");
        if constexpr (isPacketSubType<T>)
            return (std::get_if<T>(&m_data));
        return (nullptr);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    const T* getIf(void) const
    {
        static_assert(isPacketSubType<T>, "T must be a subtype of Packet");
        if constexpr (isPacketSubType<T>)
            return (std::get_if<T>(&m_data));
        return (nullptr);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam Visitor
    ///
    /// \param visitor
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename Visitor>
    decltype(auto) visit(Visitor&& visitor)
    {
        return (std::visit(std::forward<Visitor>(visitor), m_data));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam Visitor
    ///
    /// \param visitor
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename Visitor>
    decltype(auto) visit(Visitor&& visitor) const
    {
        return (std::visit(std::forward<Visitor>(visitor), m_data));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    void write(const T& value)
    {
        if (m_pos + sizeof(T) > MAX_SIZE)
            throw std::out_of_range("Packet write overflow");
        std::memcpy(m_buffer.data() + m_pos, &value, sizeof(T));
        m_pos += sizeof(T);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    void read(T& value)
    {
        if (m_pos + sizeof(T) > MAX_SIZE)
            throw std::out_of_range("Packet read overflow");
        std::memcpy(&value, m_buffer.data() + m_pos, sizeof(T));
        m_pos += sizeof(T);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    void write(const String& value);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    void write(const Vec2<T>& value)
    {
        this->write(value.x);
        this->write(value.y);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    void write(const PlayerList& value);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    void read(String& value);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    void read(Vec2<T>& value)
    {
        this->read(value.x);
        this->read(value.y);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    void read(PlayerList& value);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    const Byte* data(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Byte* data(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Uint64 size(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    void clear(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    void serialize(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    void deserialize(void);
};

} // namespace tkd

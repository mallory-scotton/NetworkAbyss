///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <Engine/Utils/Types.hpp>
#include <Engine/Utils/Vec2.hpp>
#include <stdexcept>
#include <cstring>

///////////////////////////////////////////////////////////////////////////////
// Namespace tkd
///////////////////////////////////////////////////////////////////////////////
namespace tkd
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class Packet
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    static const Uint64 MAX_SIZE = 1024UL;

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    enum class Type : int
    {
        Connect,            //<!
        Disconnect,         //<!
        PlayerMove,         //<!
        PlayerList,         //<!
        PlayerJoined,       //<!
        PlayerLeft          //<!
    };

private:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    Array<Byte, MAX_SIZE> m_data;       //<!
    Uint64 m_rpos = 0;                  //<!
    Uint64 m_wpos = 0;                  //<!

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    Packet(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param type
    ///
    ///////////////////////////////////////////////////////////////////////////
    Packet(Type type);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param type
    /// \param data
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    Packet(Type type, const T& data)
    {
        this->clear();
        *this << type;
        *this << data;
    }

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    Packet& operator<<(const T& value)
    {
        if (m_wpos + sizeof(T) > MAX_SIZE)
            throw std::out_of_range("Packet write overflow");
        std::memcpy(m_data.data() + m_wpos, &value, sizeof(T));
        m_wpos += sizeof(T);
        return (*this);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param value
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Packet& operator<<(const String& value);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    Packet& operator<<(const Vec2<T>& value)
    {
        *this << value.x;
        *this << value.y;
        return (*this);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    Packet& operator>>(T& value)
    {
        if (m_rpos + sizeof(T) > MAX_SIZE)
            throw std::out_of_range("Packet read overflow");
        std::memcpy(&value, m_data.data() + m_rpos, sizeof(T));
        m_rpos += sizeof(T);
        return (*this);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param value
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Packet& operator>>(String& value);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param value
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    Packet& operator>>(Vec2<T>& value)
    {
        *this >> value.x;
        *this >> value.y;
        return (*this);
    }

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    const Byte* data(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Byte* data(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Uint64 size(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    void clear(void);
};

} // namespace tkd
